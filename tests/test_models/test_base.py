#!/usr/bin/python3
import unittest
from models.base_model import BaseModel
from datetime import datetime
from io import StringIO
from unittest.mock import patch


class InstanceAttributeTestCase(unittest.TestCase):

    def test_id_is_uuid_str_format(self):
        """id should be a string type value generated by a uuid class"""

        #  use a regex testing to test that the id matches this pattern
        #  12345678-1234-5678-1234-567812345678

        a = BaseModel()
        self.assertIs(type(a.id), str)

        regex_fmt = '[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{8}'
        self.assertRegex(a.id, regex_fmt)

        my_model_json = a.to_dict()
        b = BaseModel(**my_model_json)
        self.assertIs(type(b.id), str)
        self.assertRegex(b.id, regex_fmt)

    def test_created_at_is_datetime_object(self):
        """created_at should be assigned with datetime object"""

        a = BaseModel()
        self.assertIs(type(a.created_at), datetime)

        # test that timedelta between the datetime assigned to created_at and
        # datetime.now is not greater than 5 second

        my_model_json = a.to_dict()
        b = BaseModel(**my_model_json)
        self.assertIs(type(b.created_at), datetime)

    def test_updated_at_is_datetime_object(self):
        """updated_at should be assigned with datetime object"""

        a = BaseModel()
        self.assertIs(type(a.updated_at), datetime)

        my_model_json = a.to_dict()
        b = BaseModel(**my_model_json)
        self.assertIs(type(b.updated_at), datetime)


class StrAttrTestCase(unittest.TestCase):
    """__str__ should print [<class name>] (<self.id>) <self.__dict__>"""

    @classmethod
    def setUpClass(self):
        self.base = BaseModel()

    def test_str_attr_output(self):
        class_name = type(self.base).__name__
        id_ = self.base.id
        attr_dict = self.base.__dict__


        out = "[{}] ({}) {}".format(class_name, id_, attr_dict)

        with patch('sys.stdout', new=StringIO()) as output:
            print(self.base)
            print_out = output.getvalue().strip()
            self.assertEqual(print_out, out)

class SaveMethodTestCase(unittest.TestCase):


    def test_updated_at_is_changed(self):
        """save should update the public instance attribute updated_at"""
        a = BaseModel()
        time_before_save = a.updated_at
        a.name = "John"
        a.my_number = 89
        a.save()
        time_after_save = a.updated_at

        self.assertIs(type(a.updated_at), datetime)
        self.assertNotEqual(time_before_save, time_after_save)

class TodictMethodTestCase(unittest.TestCase):


    def test_todict_return_type(self):
        """to_dict should return a dictionary object"""
        a = BaseModel()
        self.assertIs(type(a.to_dict()), dict)


    # Test that the dictionary returned by to_dict() contains the key
    # __class__

    def test_todict_content(self):
        """to_dict should return a dict containing all key/values of __dict__
        """
        a = BaseModel()

        a.name = "Gilbert"
        a.lastname = "Adikankwu"
        a.my_number = 89

        attr_dict = a.__dict__
        to_dict = a.to_dict()
        to_dict_keys = list(to_dict.keys())

        for k in attr_dict.keys():
            self.assertIn(k, to_dict_keys)


    def test_todict_content2(self):
        """to_dict should return a dict containing a __class__ key"""

        a = BaseModel()

        attr_dict = a.__dict__
        to_dict = a.to_dict()
        to_dict_keys = list(to_dict.keys())

        self.assertIn("__class__", to_dict_keys)


    def test_updatedat_value_is_string_ISO_format(self):
        """value of key updated_at should be string in ISO format
        """
        a = BaseModel()

        attr_dict = a.__dict__
        # convert values of updated_at and created_at to ISO format string
        time_fmt = '%Y-%m-%dT%H:%M:%S.%f'
        updated_at_str = attr_dict['updated_at'].strftime(time_fmt)

        to_dict = a.to_dict()

        self.assertEqual(updated_at_str, to_dict['updated_at'])


    def test_created_at_value_is_string_ISO_format(self):
        """value of key created_at should be string in ISO format"""

        a = BaseModel()

        attr_dict = a.__dict__

        time_fmt = '%Y-%m-%dT%H:%M:%S.%f'
        created_at_str = attr_dict['created_at'].strftime(time_fmt)
        to_dict = a.to_dict()

        self.assertEqual(created_at_str, to_dict['created_at'])


    # Test that the instance dict attr before to_dict is called is equal to the
    # dict returned
    # added to its attribute dict ==
    # the return value ofObject.to_dict()

if __name__ == "__main__":
    unittest.main()
